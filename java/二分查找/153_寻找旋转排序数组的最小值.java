//因为按照题目的意思，数组是被分为了两半，数组肯定存在最小值，只是这个最小值的位置是不定的，可能在两个边界，也可能在中间。
//只是和二分查找的写法不一样了，只是二分的思想。因为我们考虑的区间这次是0~n-2,r的值可以这么理解。
//给定的数组不空，且互不相通。
//思路：nums[mid] < nums[n - 1] 的时候，说明最小值在第二段，mid在最小值的右边，所以修正r，另一边反之。
class Solution {
    public int findMin(int[] nums) {
        int n = nums.length;
        int l = 0;
        int r = n - 2;//因为每次和n-1比较，要是n-1是最小的，循环结束，l就是n-1
        while(l <= r){
            int mid = (l + r) >>> 1;//闭区间写法，无符号右移
            if(nums[mid] < nums[n - 1]){//二分本质是区间长度根据规则进行判断，左边界或者右边界会缩减导致区间缩短，当区间不合法时就会产生答案
                r = mid - 1;//mid在最小值右边
            }else{
                l = mid + 1;//l在最小值左边，或者等于最小值
            }
        }
        return nums[l];
    }
}