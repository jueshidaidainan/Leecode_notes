//这题保证了可以到最后一个点，要求跳到终点的最小次数（当然不保证到终点是hard题）
//下面是灵神的解法。思路是：建桥。走过一段桥，然后维护这段桥上能到的最远位置，当这段桥到头了的时候，建桥，并更新最远可到地方。

//为什么这种贪心的思想是对的呢？因为我们一般认为局部最优不一定是全局最优。   但是，回过头想，我们在每一个区间内找的是最远的位置，这样我们获得了最远的视野域（再更逼近终点的同时，我们考虑了区间内的所有情况），如果不是最远的位置，次远的位置，可能会需要多跳一次。
//for循环为什么是到n-2？  因为是建桥的数量，代码的逻辑是当前位置是否需要建桥i==curRight，所以i不能等于n-1,因为终点不需要修桥。
class Solution {
    public int jump(int[] nums) {
        int ans = 0;
        int curRight = 0; //当前桥的最右端
        int nextRight = 0;//走过当前桥，发现这段路程，最远可以到达的地方
        for(int i = 0; i < nums.length - 1; i++){//终点不需要修桥
            nextRight = Math.max(nextRight, i + nums[i]);//维护最远可到地方
            if(i == curRight){//无路可走，必须建桥
                curRight = nextRight;
                ans++;
            }
        }
        return ans;
    }
}