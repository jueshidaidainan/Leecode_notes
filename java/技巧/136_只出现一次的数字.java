//这道题真的技巧性很强，第一次主观想到的方法是利用hash的方法，遍历并存储每个元素出现的次数，不过似乎得遍历两次，一次存储次数，一次遍历次数。
//但是题目要求O(n)的时间复杂度和O(1)的空间复杂度，所以只能利用异或运算了。
//异或运算，相同为0，不同为1，所以异或运算后，所有相同的数字异或结果为0，最终结果就是只出现一次的数字。
// 而且0与任何数符异或结果为自身。
//异或运算自身满足交换律和结合律，所以循环操作本身可以利用交换律将相同的数字进行异或，最终得到的就是单独的那个数字。
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for(int x : nums){
            res ^= x;
        }
        return res;
    }
}
